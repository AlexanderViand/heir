#ifndef LIB_TRANSFORMS_VALIDATENOISE_VALIDATENOISE_TD_
#define LIB_TRANSFORMS_VALIDATENOISE_VALIDATENOISE_TD_

include "mlir/Pass/PassBase.td"

def ValidateNoise : Pass<"validate-noise"> {
  let summary = "Validate the HE circuit against a given noise model";
  let description = [{
    // DEVELOPER NOTE: This pass implements noise analysis validation for FHE circuits to ensure
    // decryption correctness. It uses the same noise models as parameter generation but performs
    // forward analysis to verify that actual noise growth stays within computed bounds.
    //
    // Implementation details:
    // - Reads scheme parameters from module attributes (generated by generate-param-* passes)
    // - Performs forward dataflow analysis tracking noise accumulation through operations
    // - Uses operation-specific noise growth models matching the specified noise model
    // - Reports analysis results via debug output for user inspection
    // - Optionally annotates IR with computed noise bounds for further analysis
    //
    // Noise tracking methodology:
    // - Fresh ciphertexts: Start with base noise from encryption
    // - Additions: Noise grows additively (worst case of operand noises)
    // - Multiplications: Noise grows multiplicatively plus additional terms
    // - Relinearizations: Add relinearization noise but reduce ciphertext size
    // - Management operations: Track noise effects of level/modulus changes
    //
    // Model integration:
    // - Reuses noise estimation code from parameter generation for consistency
    // - Supports all noise models available in generate-param passes
    // - Provides same noise bound calculations but in validation context
    // - Enables verification that parameter generation was sufficient
    //
    // Reusability considerations:
    // - Noise analysis framework can be extended to new FHE schemes
    // - Model-agnostic interface allows easy addition of new noise models
    // - Debug output format standardized for tooling integration
    // - Analysis results can be consumed by other optimization passes
    //
    // Validation workflow:
    // 1. Extract scheme parameters from IR attributes
    // 2. Initialize noise tracker with fresh ciphertext noise
    // 3. Propagate noise through all operations using selected model
    // 4. Compare accumulated noise against decryption thresholds
    // 5. Report success/failure and detailed analysis via debug output
    //
    // Debugging capabilities:
    // - Per-value noise tracking for precise error localization
    // - Noise budget reporting (remaining capacity before failure)
    // - Integration with MLIR debug infrastructure for detailed output
    // - Optional IR annotation for persistent noise bound information
    This pass validates the noise of the HE circuit against a given noise model.

    The pass expects the scheme parameters to be annotated in the IR. Usually
    this is done by the `generate-param-<scheme>` passes.

    For available noise models, see `generate-param-<scheme>` passes.

    The result should be observed using --debug-only=ValidateNoise.

    Example
    ```bash
    # with commandline --debug-only=ValidateNoise
    Noise Bound: 29.27 Budget: 149.73 Total: 179.00 for value: <block argument> of type 'tensor<8xi16>' at index: 0
    Noise Bound: 29.27 Budget: 149.73 Total: 179.00 for value: <block argument> of type 'tensor<8xi16>' at index: 1
    ```
  }];

  let dependentDialects = [
    "mlir::heir::bgv::BGVDialect",
  ];

  let options = [
    Option<"model", "model", "std::string",
           /*default=*/"\"bgv-noise-kpz21\"", "Noise model to validate against.">,
    Option<"annotateNoiseBound", "annotate-noise-bound", "bool",
           /*default=*/"false", "Annotate the noise bound to the IR.">,
  ];
}

#endif  // LIB_TRANSFORMS_VALIDATENOISE_VALIDATENOISE_TD_
